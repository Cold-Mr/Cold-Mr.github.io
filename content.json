{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2021-06-03T14:33:43.605Z","updated":"2021-06-03T14:33:43.605Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"JVM内存模型和结构","date":"2021-06-02T08:39:40.796Z","updated":"2021-06-09T06:37:15.604Z","comments":true,"path":"2021/06/02/JVM内存模型和结构/","link":"","permalink":"http://yoursite.com/2021/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84/","excerpt":"","text":"JVM 内存模型和结构： 1. 有些区域随虚拟机的启动而存在 2. 有些区域随线程的启动而启动，随线程的结束而销毁 JVM 运行时内存结构 JVM 的内存结构大概分为： 1. 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。 2. 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。 3. 虚拟机栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。 4. 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的 Native 方法服务。如 Java 使用 c 或者 c++ 编写的接口服务时，代码在此区运行。 5. 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成 PC 寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。 堆 堆的作用是存放对象实例和数组。从结构上来分，可以分为新生代和老年代。而新生代又可以分为 Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。 所有新生成的对象首先都是放在新生代的。需要注意，Survivor 的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 Eden 复制过来的对象，和从前一个 Survivor 复制过来的对象，而复制到老年代的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。 控制参数 - Xms 设置堆的最小空间大小。-Xmx 设置堆的最大空间大小。-XX:NewSize 设置新生代最小空间大小。-XX:MaxNewSize 设置新生代最小空间大小。 垃圾回收 此区域是垃圾回收的主要操作区域。 异常情况 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常 方法区 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 很多人愿意把方法区称为 “永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如 BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。在 Java8 中永生代彻底消失了。 控制参数 - XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间。 垃圾回收 对此区域会涉及但是很少进行垃圾回收。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收 “成绩” 比较难以令人满意。 异常情况 根据 Java 虚拟机规范的规定， 当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError。 方法栈 每个线程会有一个私有的栈。每个线程中方法的调用又会在本栈中创建一个栈帧。在方法栈中会存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 控制参数 - Xss 控制每个线程栈的大小。 异常情况 在 Java 虚拟机规范中，对这个区域规定了两种异常状况： StackOverflowError： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出； OutOfMemoryError 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出。 本地方法栈 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其 区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则 是为虚拟机使用到的 Native 方法服务。 控制参数 在 Sun JDK 中本地方法栈和方法栈是同一个，因此也可以用 - Xss 控制每个线程的大小。 异常情况 与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 程序计数器 它的作用可以看做是当前线程所执行的字节码的行号指示器。 异常情况 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 常见内存溢出错误 有了对内存结构清晰的认识，就可以帮助我们理解不同的 OutOfMemoryErrors，下面列举一些比较常见的内存溢出错误，通过查看冒号 “：” 后面的提示信息，基本上就能断定是 JVM 运行时数据的哪个区域出现了问题。 Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space 原因：对象不能被分配到堆内存中。 Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space 原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库。 Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit 原因：创建的数组大于堆内存的空间。 Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space? 原因：分配本地分配失败。JNI、本地库或者 Java 虚拟机都会从本地堆中分配内存空间。 Exception in thread “main”: java.lang.OutOfMemoryError: &lt;reason&gt; &lt;stack trace&gt;（Native method） 原因：同样是本地方法内存分配失败，只不过是 JNI 或者本地方法或者 Java 虚拟机发现。 1. 不同的虚拟机实现可能不同，但是一般都会遵守规范 2. 规范中方法区只是一种概念上的区域，说明了其应该具有的功能，但并没有说明其具体应该位于何处。不同的虚拟机实现，会有一定的自由度。有些虚拟机是在堆内实现的 3. 运行时常量池用于存放编译期的各种字面值和符号引用。不过 Java 并没有要求常量只能在编译期才能产生，通过 String.intern 也能产生 4. 除了图中所列的内存区域，还有一块内存可供使用，那就是直接内存。JVM 规范并没有定义这一块区域，所以并不由 JVM 管理，是利用本地方法库直接在堆外申请的内存 5. 堆和栈的数据划分并不是绝对的，JIT 会针对对象分配做一定的优化 JVM 内存结构由 JVM 虚拟机规范定义。描述的是 java 程序执行过程中，由 JVM 管理的不同数据区域，各个区域的功能会有区别 Java 内存模型 Java 堆和方法区是多个线程共享的数据区域。多个线程可以操作堆和方法区中的同一个数据。Java 的线程间通过共享内存进行通信 1.Java 内存模型的英文名称为 Java Memory Model (JMM)，其并不想 JVM 内存结构一样真实存在，而是一个抽象的概念。通过 JSR-133 Java Memory Model and Thread Specification 中的描述，我们知道 JMM 和线程有关，它描述了一组规范或规则，一个线程对共享变量的写入时对另一个线程是可见的。 2.Java 多线程对共享内存进行操作的时候，会存在一些如可见性、原子性和顺序性的问题，JMM 是围绕着多线程通信及相关的一些特性而建立的模型。而 JMM 定义了一些语法集，而这些语法集映射到 Java 语言的 volatile、synchronized 等关键字 Java 对象模型 Java 对象在 JVM 中的存储有一定的结构，Java 对象自身的存储模型就叫做 Java 对象模型。 总： JVM 内存结构，和 Java 虚拟机的运行时区域有关。 Java 内存模型，和 Java 的并发编程有关。 Java 对象模型，和 Java 对象在虚拟机中的表现形式有关。","categories":[],"tags":[]},{"title":"","slug":"a","date":"2021-06-02T08:33:45.672Z","updated":"2021-06-09T06:36:56.461Z","comments":true,"path":"2021/06/02/a/","link":"","permalink":"http://yoursite.com/2021/06/02/a/","excerpt":"","text":"AT 计划在计算机上运行的命令和程序。 ATTRIB 显示或更改文件属性。 BREAK 设置或清除扩展式 CTRL+C 检查。 CACLS 显示或修改文件的访问控制列表 (ACLs)。 CALL 从另一个批处理程序调用这一个。 CD 显示当前目录的名称或将其更改。 CHCP 显示或设置活动代码页数。 CHDIR 显示当前目录的名称或将其更改。 CHKDSK 检查磁盘并显示状态报告。 CHKNTFS 显示或修改启动时间磁盘检查。 CLS 清除屏幕。 CMD 打开另一个 Windows 命令解释程序窗口。 COLOR 设置默认控制台前景和背景颜色。 COMP 比较两个或两套文件的内容。 COMPACT 显示或更改 NTFS 分区上文件的压缩。 CONVERT 将 FAT 卷转换成 NTFS。您不能转换当前驱动器。 COPY 将至少一个文件复制到另一个位置。 DATE 显示或设置日期。","categories":[],"tags":[]},{"title":"newpapername","slug":"newpapername","date":"2021-06-02T07:25:48.000Z","updated":"2021-06-02T07:27:34.734Z","comments":true,"path":"2021/06/02/newpapername/","link":"","permalink":"http://yoursite.com/2021/06/02/newpapername/","excerpt":"","text":"# 目标 去除 iconfinder 上 icon 的水印 # 原理 利用水印像素点和原图像素点颜色合并的原理，如果拥有加过水印的图片和水印图片，就可以反向推出原图原像素点的颜色；前提是你得拥有他的水印图片","categories":[],"tags":[]}],"categories":[],"tags":[]}